// Author: Salim Afiune <afiune@chef.io>

package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"go/format"
	"io/ioutil"
	"net/http"
	"os"
	"text/template"
	"time"
)

// A simple generator for creating easily distributable Go packages
//
// This automation is providing an easy way to generate variables that can be configured,
// globally across multiple go packages, things like trademarks, product names, websites,
// etc., this generator should be defined as a `go:generate` comment and run at build time
// using the `go generate` command.
//
// Example-1: Simple use within a single main package, create a file called dist_gen.go with:
//
// ```go
// package main
// //go:generate go run github.com/afiune/godist
// ```
//
// The automation will deploy a file called `dist.go` with all the variables defined inside
// the JSON file `glob_dist.json` inside this repository. (find a real example at example-main/)
//
// Example-2: Multi-package, create a go package called dist/ with a file called `gen.go` with:
//
// ```go
// package dist
// //go:generate go run github.com/afiune/godist global.go dist
// ```
//
// This usage is for go projects that has multiple packages, by creating a single `dist` package
// inside your repository, you can import the generated package in any other packages. (find a
// real example at example-multi-pkg/)
//
// Example-3: Using a custom JSON file containing global variables
//
// ```go
// package dist
// //go:generate go run github.com/afiune/godist global.go dist http://shorturl.at/arxQX
// ```
//
// To fully customize this automation, a user can also provide a custom URL poiting to a JSON file
// that contains the the global variables to define.
//

var (
	globalVariables map[string]string
	tplBuf          bytes.Buffer

	// the file name that this automation will generate (default `dist.go`)
	//
	// *customizable* (args:1)
	goFileName = "dist.go"

	// the go package to use inside the generated file.go (default: `main`)
	//
	// *customizable* (args:2)
	goPackage = "main"

	// a JSON format file where the global variables are defined
	// (by default the automation use the local `glob_dist.json`)
	//
	// *customizable* (args:3)
	globDistJson = "https://raw.github.com/afiune/godist/master/glob_dist.json"

	// a dist template to generate global variables
	// NOTE: @afiune in the future if there are more customizations we need
	// to add we could either modify this template or create new ones
	distTemplate = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT.
//
// file generated at: {{ .Timestamp }}
// using data from:   {{ .URL }}
// and generator:     https://github.com/afiune/godist
//

package {{ .GoPackage }}

var (
{{- range $varName, $varValue := .GlobalVariables }}
  {{ printf "%v = %q" $varName $varValue }}
{{- end }}
)
`))
)

func fatal(msg string, err error) {
	fmt.Fprintf(os.Stderr, "%s: %s", msg, err.Error())
	os.Exit(1)
}

func main() {
	if len(os.Args) > 1 {
		goFileName = os.Args[1]
	}

	if len(os.Args) > 2 {
		goPackage = os.Args[2]
	}

	if len(os.Args) > 3 {
		globDistJson = os.Args[3]
	}

	rsp, err := http.Get(globDistJson)
	if err != nil {
		fatal("failed to get global variables file", err)
	}

	jsonRaw, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		fatal(fmt.Sprintf("failed to read body from %s", globDistJson), err)
	}

	err = json.Unmarshal(jsonRaw, &globalVariables)
	if err != nil {
		fatal("failed to unmarshal raw json", err)
	}

	err = distTemplate.Execute(&tplBuf, struct {
		Timestamp       time.Time
		URL             string
		GoPackage       string
		GlobalVariables map[string]string
	}{
		Timestamp:       time.Now(),
		URL:             globDistJson,
		GoPackage:       goPackage,
		GlobalVariables: globalVariables,
	})
	if err != nil {
		fatal("failed to write template", err)
	}

	f, err := os.Create(goFileName)
	if err != nil {
		fatal("failed to create file", err)
	}
	defer f.Close()

	// two reasons why we format the go template:
	// 1) to have a nice format :wink:
	// 2) also to verify that the generate go code is parsable/executable
	formatted, err := format.Source(tplBuf.Bytes())
	if err != nil {
		fatal("unable to format generate go template", err)
	}

	_, err = f.Write(formatted)
	if err != nil {
		fatal("failed to write file", err)
	}
}
